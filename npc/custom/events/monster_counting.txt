// Emistry - rAthena Forum
// modified by Nubs
prontera,146,154,5	script	Poring Counting	757,{
	function xy_wall;
	function set_zone;
	function reset_game;

	set .@n$,"[^0000FFPoring Counting^000000]";

	if (getgmlevel()>=.@GMLevel) {
		mes .@n$;
		mes "Select an option.";
		if (.EventON || .aTimer) {
			mes "The Event is currently: [^0000FFON^000000]";
			mes "Would you like to turn it OFF?";
		} else {
			mes "The Event is currently: [^FF0000OFF^000000]";
			mes "Would you like to turn it ON?";
		}
		if(select("Yes:No")==2) close;
		if (.EventON) {
			reset_game();
			announce "<Poring Counting> A GM has decided to turn the Disguise Event off. As a result no further prizes will be given.",bc_map | bc_blue;
			close;
		}
		goto OnStartGame;
	}
	end;

	// The ACTUAL Start of the Event
	OnStartPCounting:
		// make sure the zone are set
		if(.EventON == 0) set_zone();

		npctalk "Round # "+(.RoundCount+1);
		.EventON = 2; // Monster Spawned flag

		.mob = .monster[ rand( .monster_size ) ];
		.@size = getmonsterinfo(.mob, MOB_SIZE);

		// add-on size influence ?
		if(.@size == 0)
			.@amount = rand( 25,55 );
		else if (.@size == 1)
			.@amount = rand( 20,45 );
		else if (.@size == 2)
			.@amount = rand( 15,35 );
		else
			.@amount = rand( 15,55 ); // fallback

		set .Winner,0; // stop from having duplicate winners
		// spawned monster in the bounding box
		areamonster .map$,.xy_area[0],.xy_area[1],.xy_area[2],.xy_area[3],"",.mob,.@amount,.npc_name$+"::OnDied";

		deletepset 1; // delete previous answer regardless if there is any
		// Execute OnCorrectAnswer when someone answer correctly
		defpattern 1,"([^:]+):.\\s*"+.@amount+"$", "OnCorrectAnswer";
		activatepset 1;

		// Chatroom to display the question
		waitingroom "How many is there?", 0;
		npctalk "<Poring Counting> Tell me the correct amount of " + getmonsterinfo(.mob,MOB_NAME) + " in there.";
		debugmes " > "+.@amount+" "+getmonsterinfo( .mob,MOB_NAME );
		setnpctimer 0; // start 30s timer
		end;

	// The ACTUAL End of the event
	OnEndPCounting:
	OnCorrectAnswer:
		getmapxy( .@map$,.@x,.@y,0 );
		if ( .EventON == 0 ) {
			dispbottom "<Poring Counting> Event isnt running.";
		}
		else if ( .EventON == 1 ) {
			dispbottom "<Poring Counting> Please wait for the round to start.";
		}
		else if ( distance( .npc_x,.npc_y,.@x,.@y ) > 14 ) {
			dispbottom "<Poring Counting> You're too far away.";
		}
		else if (.Winner) {
			dispbottom "<Poring Counting> Someone has already won this round.";
		}
		else {
			announce "Bravo!! " + strcharinfo(0) + " is correct!",bc_map | bc_blue;
			.Winner = 1; // stop from having duplicate winners, incase the event executed twice
			.EventON = 1;

			getitem 8501, 1; // reward
			// kill any surving monster
			killmonster .map$,.npc_name$+"::OnDied";
			// clean up previous rounds data
			delwaitingroom;
			deletepset 1; // disable answer

			.RoundCount = .RoundCount+1;
			if (.RoundCount < .Rounds) {
				sleep 2000;
				npctalk "<Poring Counting> Starting a new round...";
				setnpctimer 0;  // start 3s timer
			}
			else
			{ // completed all rounds
				reset_game();
				npctalk "<Poring Counting> The event is now over.";
				emotion ET_THANKS;
				sleep 1000;
				npctalk "<Poring Counting> Thank you for playing and please come and play again later.";
			}
		}
		end;

	// Event Timer
	OnTimer5000: // Round Start Timer
		// skip this if the announcement or event is running
		if (.aTimer || .EventON == 2) end;
		goto OnStartPCounting;
		end;

	OnTimer30000: // Round Timer Ends
		// skip this if the announcement is running
		if (.aTimer) end;

		npctalk "<Poring Counting> You took too long to guess the number of "+ getmonsterinfo(.mob,MOB_NAME) +".";
		// kill any surving monster
		killmonster .map$,.npc_name$+"::OnDied";

		// clean up previous rounds data
		delwaitingroom;
		deletepset 1; // disable answer

		.RoundCount = .RoundCount+1;
		setnpctimer 0; stopnpctimer;
		if (.RoundCount < .Rounds) {
			npctalk "<Poring Counting> Please wait 5 seconds while I start the next round.";
			.EventON = 1; initnpctimer;
		}
		else
		{
			reset_game();

			npctalk "<Poring Counting> The event is now over.";
			emotion ET_THANKS;
			sleep 1000;
			npctalk "Thank you for playing and please come and play again later.";
		}
		end;

	// Announcements
	OnClock0030:
	OnClock0230:
	OnClock0430:
	OnClock0630:
	OnClock0830:
	OnClock1030:
	OnClock1230:
	OnClock1430:
	OnClock1630:
	OnClock1830:
	OnClock2030:
	OnClock2230:
	OnStartGame:
		.RoundCount = 0;
		announce "The <Poring Counting> is being held in Prontera (146 154) will begin in 3 minutes.",bc_all | bc_blue;
		set .aTimer, 1; // Announcement Timer
		setnpctimer 0; initnpctimer;
		end;
	OnTimer6000:
		if (.aTimer!=1) end;
		announce "The <Poring Counting> is being held in Prontera (146 154) will begin in 2 minutes.",bc_all | bc_blue;
		end;
	OnTimer12000:
		if (.aTimer!=1) end;
		announce "The <Poring Counting> is being held in Prontera (146 154) will begin in 1 minutes.",bc_all | bc_blue;
		end;
	OnTimer18000:
		if (.aTimer!=1) end;
		announce "The <Poring Counting> has begun!",bc_all | bc_blue;
		set .aTimer,0; stopnpctimer;
		setnpctimer 0; initnpctimer;

		set_zone(); // set the boundaries
		goto OnStartPCounting; // start the event
		end;

	OnInit:
		.@GMLevel = 60;	// GM level required to access NPC.
		.Rounds = 3;
		.wall_mob_id = 1085; // Red Mushroom
		setarray .xy_area,
			150,148,
			161,159;
		setarray .monster,
			1002, // poring
			1894, // pouring
			1852, // angeling
			2933, // deviling
			1613, // metaling
			1977, // heavy metaling
			2934, // arc angeling
			1062, // santa poring
			2398, // little poring
			1836, // magmaring
			1113, // drops
			2316, // jejeling
			1857, // marin,
			2936, // ghostring
			2248, // golden poring
			3508, // eggring
			3505, // big eggring
			1031; // poporing;
		.mob = 0;

		.monster_size = getarraysize( .monster );
		.npc_name$ = strnpcinfo(0);
		getmapxy( .map$,.npc_x,.npc_y,1 );
		setmapflag .map$,mf_monster_noteleport;
		reset_game();
		end;

	OnDied:
	OnWallDied:
		end;

	function set_zone {
		areawarp .map$,.xy_area[0],.xy_area[1],.xy_area[2],.xy_area[3],.map$,.npc_x,.npc_y;
		killmonster .map$,.npc_name$+"::OnDied";
		killmonster .map$,.npc_name$+"::OnWallDied";

		setcell .map$,.xy_area[0]-15,.xy_area[1]-15,.xy_area[2]+15,.xy_area[3]+15,CELL_LANDPROTECTOR,1;
		setcell .map$,.xy_area[0]-15,.xy_area[1]-15,.xy_area[2]+15,.xy_area[3]+15,CELL_BASILICA,1;
		setcell .map$,.xy_area[0],.xy_area[1],.xy_area[2],.xy_area[3],cell_walkable,1;

		for( .@i = .xy_area[0]; .@i <= .xy_area[2]; .@i++ ){
			xy_wall( .@i,.xy_area[1] );
			xy_wall( .@i,.xy_area[3] );
		}
		for( .@i = .xy_area[1]; .@i <= .xy_area[3]; .@i++ ){
			xy_wall( .xy_area[0],.@i,0 );
			xy_wall( .xy_area[2],.@i );
		}

		.EventON = 1; // event "boundaries" flag
		return;
	}

	function	xy_wall	{
		.@x = getarg(0);
		.@y = getarg(1);
		monster .map$,.@x,.@y,"",.wall_mob_id,1,.npc_name$+"::OnWallDied";
		setcell .map$,.@x,.@y,.@x,.@y,cell_walkable,0;

		// setcell .map$,.@x,.@y,.@x,.@y,cell_basilica,1;
		// setcell .map$,.@x,.@y,.@x,.@y,CELL_LANDPROTECTOR,1;
		return;
	}

	function reset_game {
		// kill any surving monster
		killmonster .map$,.npc_name$+"::OnDied";
		killmonster .map$,.npc_name$+"::OnWallDied";

		// clean up previous rounds data
		delwaitingroom;
		deletepset 1; // disable answer
		.EventON = 0; .aTimer = 0;
		setnpctimer 0; stopnpctimer;

		setcell .map$,.xy_area[0]-15,.xy_area[1]-15,.xy_area[2]+15,.xy_area[3]+15,CELL_LANDPROTECTOR,0;
		setcell .map$,.xy_area[0]-15,.xy_area[1]-15,.xy_area[2]+15,.xy_area[3]+15,CELL_BASILICA,0;
		setcell .map$,.xy_area[0]-1,.xy_area[1]-1,.xy_area[2]+1,.xy_area[3]+1,cell_walkable,1;
		return;
	}
}